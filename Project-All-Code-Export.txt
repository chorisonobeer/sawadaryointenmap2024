<documents>
<document index="1">
<source>package.json</source>
<document_content>
{
  "name": "geolonia-pwa",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.8.2",
    "@emotion/styled": "^11.8.1",
    "@mapbox/geojson-extent": "^1.0.1",
    "@material-ui/core": "^5.0.0-beta.5",
    "@testing-library/jest-dom": "^5.16.2",
    "@testing-library/react": "^12.1.4",
    "@testing-library/user-event": "^13.5.0",
    "@turf/turf": "^6.5.0",
    "@types/jest": "^27.4.1",
    "@types/node": "^17.0.22",
    "@types/react": "^17.0.41",
    "@types/react-dom": "^17.0.14",
    "chalk": "^5.0.1",
    "csv-parse": "^4.8.8",
    "icon-gen": "^3.0.0",
    "next-qrcode": "^2.5.1",
    "papaparse": "^5.4.1",
    "pwa-asset-generator": "^6.0.6",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-icons": "^4.3.1",
    "react-infinite-scroll-component": "^6.1.0",
    "react-router-dom": "^6.2.2",
    "react-scripts": "^5.0.1",
    "react-select": "^5.2.2",
    "react-share": "^4.4.0",
    "react-stars": "^2.2.5",
    "typescript": "~4.6.2"
  },
  "scripts": {
    "start": "node bin/config.js && react-scripts start",
    "build": "node bin/config.js && react-scripts build",
    "build:assets": "pwa-asset-generator public/logo.svg ./public/ --index ./public/index.html --manifest ./public/manifest.json --favicon true",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "homepage": ".",
  "eslintConfig": {
    "extends": "react-app"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@types/papaparse": "^5.3.14",
    "@types/react-infinite-scroller": "^1.2.3",
    "@types/react-router-dom": "^5.3.3",
    "@types/react-stars": "^2.2.1",
    "axios": "^0.26.1",
    "node-fetch": "2",
    "sass": "^1.49.9",
    "stream-browserify": "^3.0.0",
    "yaml": "^1.10.2"
  }
}

</document_content>
</document>
<document index="2">
<source>README.md</source>
<document_content>
# Geolonia PWAマップ

## Geolonia PWAマップ について

Geolonia PWA は、GitHub と Google Sheets を使って、素早く PWA の地図アプリが作れるテンプレートです。

## フォーク

まず、以下のリポジトリをフォークしてください。
https://github.com/geoloniamaps/pwamap


## サイト全体の設定

`config.yml` を書き換えることでサイト全体の設定を変更できます。

設定の例:
```
title: Geolonia PWAマップ
description: Google スプレッドシートを更新するだけでオリジナルの地図アプリを作成できる\n「Geolonia PWAマップ」
data_url: https://docs.google.com/spreadsheets/d/1_m8s4P5tdSeam3nzC5ruSfuvtSejQKEX1FiBeOWJN3E/pub?gid=1957425126&single=true&output=csv
form_url: ""
logo_image_url: https://geoloniamaps.github.io/pwamap/icon-pwamap.svg
background_image_url: https://geoloniamaps.github.io/pwamap/geolonia_bgimage_1920_1080.png
primary_color: "#d2691e"
orderby: distance
```

- `title`: サイトのタイトルです。
- `description`: サイトの概要文です。
- `data_url`: アプリで読み込む CSV データまでの URL を記述してください。SSL は必須です。
- `form_url`: データの追加/更新用の申請フォームの URL を記述してください。
- `logo_image_url`: PCで表示した時のロゴ画像の URL を記述してください。
- `background_image_url`: PCで表示した時の背景画像の URL を記述してください。
- `primary_color`: サイトのテーマカラーを記述してください。（例: `#d2691e`）
- `orderby`: 一覧ページのデータの並び順を指定します。`distance` で距離順に並び替えます。`time` で新着順に並び替えます。

## スポットデータについて

スポットは CSV 以下の方法でスポットデータファイルを作成して、`config.yml` にその CSV までの URL を設定してください。  

- `緯度`、`経度`、`スポット名`、`カテゴリ` のみが必須で、これらのどれか一つでも入力されていないとアプリ上には表示されません。
- なお、データは AJAX で常時読み込んでいますので、CSV が編集されるとほぼ同時にアプリ側にも反映されると考えてください。（キャッシュで多少タイムラグがあります。）

### Google スプレッドシートを使う方法
以下のスプレッドシートをコピーしてください。

https://docs.google.com/spreadsheets/d/1_m8s4P5tdSeam3nzC5ruSfuvtSejQKEX1FiBeOWJN3E/edit?usp=sharing

次に共有設定を行ってください。

<img width="80%" alt="" src="https://github.com/user-attachments/assets/8a2f5031-ae90-4dd4-a2f1-4c2a1db70f42">


Webへの公開設定で、「スポットデータ」シートを選択し、「カンマ区切り（.csv）」を選択して公開して下さい。


<img width="80%" alt="" src="https://github.com/user-attachments/assets/7c437ceb-21a3-4f06-9abc-5f798c7ba44a">

公開をクリックし、表示された URL を `config.yml` の `data_url` に指定して下さい。  
GitHub Pages の設定をし、 コミットするとデータが反映されます。

## 開発

[Geolonia PWA マップ ユーザーマニュアル](https://blog.geolonia.com/2022/05/17/pwamap-manual-setup.html) の手順を実行、その後以下のコマンドを実行して下さい。

```shell
$ git clone git@github.com:geoloniamaps/pwa.git
$ cd pwa
$ npm install
$ npm start
```

下の URL にアクセスして下さい。開発サーバーが立ち上がります。

`http://localhost:3000/#/`


## 注意事項
このプログラムは自由にカスタマイズ可能ですが、利用についてはサポート対象外となります。


</document_content>
</document>
<document index="3">
<source>tsconfig.json</source>
<document_content>
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "noFallthroughCasesInSwitch": true
  },
  "include": [
    "src"
  ]
}

</document_content>
</document>
<document index="4">
<source>bin\config.js</source>
<document_content>
/**
 * @file YAML 形式の設定ファイルをパースし 環境変数として react-scripts に読み込ませる
 */

const fs = require("fs");
const YAML = require("yaml");
const path = require("path")

const srcConfigFilePath = path.join(process.cwd(), "/config.yml");
const distConfigFilePath = path.join(process.cwd(), "/src/config.json");

let yamlText;
try {
  yamlText = fs.readFileSync(srcConfigFilePath).toString();
} catch (error) {
  process.stderr.write(`${srcConfigFilePath} が存在しません。\n`);
  process.exit(1);
}

let config;
try {
  config = YAML.parse(yamlText);
} catch (error) {
  process.stderr.write(
    `${srcConfigFilePath} は正しい YAML 形式である必要があります。\n`
  );
  process.exit(2);
}

if (!config) {
  process.stderr.write(
    `${srcConfigFilePath} は正しい YAML 形式である必要があります。\n`
  );
  process.exit(3);
}

const envText =
  Object.keys(config)
    // オブジェクト等は環境変数として出力しない
    .filter((key) => typeof config[key] === "string" || typeof config[key] === "number")
    .map((key) => `REACT_APP_${key.toUpperCase()}="${config[key]}"`)
    .join("\n") + "\n";

// 全ての設定は src/config.json として出力する
fs.writeFileSync(distConfigFilePath, JSON.stringify(config, null, 2));

fs.writeFileSync(path.join(process.cwd() , '.env'), envText)
process.exit(0);

</document_content>
</document>
<document index="5">
<source>public\index.html</source>
<document_content>
<!DOCTYPE html>
<html lang="ja">
  <head>
    <style>
      :root {
        --primary-color: %REACT_APP_PRIMARY_COLOR%;
        --background-image: url(%REACT_APP_BACKGROUND_IMAGE_URL%);
      }
    </style>
    <meta charset="utf-8">
    <link href="./style.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/earlyaccess/nicomoji.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,maximum-scale=1,viewport-fit=cover,minimal-ui,height=device-height">
    <meta name="theme-color" content="#FFFFFF">
    <meta name="description" content="%REACT_APP_TITLE%">
    <meta name="apple-mobile-web-app-title" content="%REACT_APP_TITLE%">
    <meta name="twitter:card" content="summary_large_image">
    <meta property="og:url" content="%REACT_APP_HOMEPAGE_URL%">
    <meta property="og:title" content="%REACT_APP_TITLE%">
    <meta property="og:image" content="%REACT_APP_HOMEPAGE_URL%apple-splash-1136-640.jpg">
    <meta property="og:type" content="website">

    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json">

    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.
      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>%REACT_APP_TITLE%</title>
    <link rel="icon" type="image/png" sizes="196x196" href="favicon-196.png">
    <link rel="apple-touch-icon" href="apple-icon-180.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="apple-touch-startup-image" href="apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root">
      <div class="loader"><img src="./manifest-icon-512.maskable.png" alt=""><br>%REACT_APP_TITLE%</div>
    </div>
    <a class="github-fork-ribbon" href="https://github.com/geoloniamaps/pwamap/" data-ribbon="Fork me on GitHub" title="Fork me on GitHub">Fork me on GitHub</a>
    <script type="text/javascript" src="https://cdn.geolonia.com/v1/embed?geolonia-api-key=YOUR-API-KEY"></script>
  </body>
</html>
</document_content>
</document>
<document index="6">
<source>public\manifest.json</source>
<document_content>
{
  "short_name": "Geolonia PWA",
  "name": "Geolonia PWA",
  "icons": [
    {
      "src": "manifest-icon-192.maskable.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "manifest-icon-192.maskable.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "manifest-icon-512.maskable.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "manifest-icon-512.maskable.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#FFFFFF",
  "background_color": "#ffffff"
}
</document_content>
</document>
<document index="7">
<source>public\style.css</source>
<document_content>
html, body, #root
{
  width: 100%;
  height: 100%;
  -webkit-text-size-adjust: none;
}

#root
{
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  background: none;
}

#root > .loader
{
  width: 192px;
  font-size: 32px;
  text-align: center;
}

img
{
  max-width: 100%;
}

@media only screen and (max-width: 960px) {
  .github-fork-ribbon
  {
    display: none;
  }

  #root
  {
    background: none !important;
  }
}

</document_content>
</document>
<document index="8">
<source>src\App.tsx</source>
<document_content>
import React from "react";
import { Routes, Route } from "react-router-dom";
import "./App.scss";

import Home from './App/Home'
import List from './App/List'
import AboutUs from './App/AboutUs'
import Category from './App/Category'
import Images from './App/Images'

import Tabbar from './App/Tabbar'
import config from "./config.json";
import Papa from 'papaparse'

// You can see config.json after running `npm start` or `npm run build`
// import config from './config.json'

const sortShopList = async (shopList: Pwamap.ShopData[]) => {

  // 新着順にソート
  return shopList.sort(function (item1, item2) {
    return Date.parse(item2['タイムスタンプ']) - Date.parse(item1['タイムスタンプ'])
  });

}

const App = () => {
  const [shopList, setShopList] = React.useState<Pwamap.ShopData[]>([])

  React.useEffect(() => {
    fetch(config.data_url)
    .then((response) => {
      return response.ok ? response.text() : Promise.reject(response.status);
    })
    .then((data) => {

      Papa.parse(data, {
        header: true,
        complete: (results) => {
          const features = results.data

          const nextShopList: Pwamap.ShopData[] = []
          for (let i = 0; i < features.length; i++) {
            const feature = features[i] as Pwamap.ShopData
            if (!feature['緯度'] || !feature['経度'] || !feature['スポット名']) {
              continue;
            }
            if (!feature['緯度'].match(/^[0-9]+(\.[0-9]+)?$/)) {
              continue
            }
            if (!feature['経度'].match(/^[0-9]+(\.[0-9]+)?$/)) {
              continue
            }
            const shop = {
              // @ts-ignore
              index: i,
              ...feature
            }

            nextShopList.push(shop)
          }
          sortShopList(nextShopList).then((sortedShopList) => {
            setShopList(sortedShopList)
          })
        }
      });
    });
  }, [])


  return (
    <div className="app">
      <div className="app-body">
        <Routes>
          <Route path="/" element={<Home data={shopList} />} />
          <Route path="/list" element={<List data={shopList} />} />
          <Route path="/category" element={<Category data={shopList} />} />
          <Route path="/images" element={<Images data={shopList} />} />
          <Route path="/about" element={<AboutUs />} />
        </Routes>
      </div>
      <div className="app-footer">
        <Tabbar />
      </div>
    </div>
  );
}

export default App;

</document_content>
</document>
<document index="9">
<source>src\config.json</source>
<document_content>
{
  "title": "佐和田料飲店MAP2024",
  "description": "新潟県佐渡市 佐和田地区の料飲店MAPです。皆さんご活用ください。",
  "data_url": "https://docs.google.com/spreadsheets/d/e/2PACX-1vQ-oIwOwd4-IVCaKZgsAxQNkac7QlikoMCGgY0ITCuuCTdwejTZYGGh4S3Vmp7N_dl1XhPtsYEHzLxs/pub?gid=1957425126&single=true&output=csv",
  "form_url": null,
  "logo_image_url": "https://geoloniamaps.github.io/pwamap/icon-pwamap.svg",
  "background_image_url": "https://geoloniamaps.github.io/pwamap/geolonia_bgimage_1920_1080.png",
  "primary_color": "#2f78ed",
  "orderby": "distance"
}
</document_content>
</document>
<document index="10">
<source>src\Container.tsx</source>
<document_content>
import React from "react";

import App from './App'
import About from './About'
import './Container.scss'

function Content() {
  return (
    <div className="outer-container">
      <div className="inner-container">
        <About />
        <App />
      </div>
    </div>
  );
}

export default Content;

</document_content>
</document>
<document index="11">
<source>src\geolocation.ts</source>
<document_content>
export const askGeolocationPermission = () => {
  return new Promise<Pwamap.LngLat | null>((resolve, reject) => {

    if(!window.navigator.geolocation || !window.navigator.geolocation.getCurrentPosition) {
      resolve(null)
    }

    window.navigator.geolocation.getCurrentPosition(
      (pos) => {
        const lat = pos.coords.latitude
        const lng = pos.coords.longitude
        resolve([lng, lat])
      },
      (error) => {
        resolve(null)
      },
      {
        enableHighAccuracy: true,
        timeout: 5000,
        maximumAge: 0
      }
    )
  })
}

</document_content>
</document>
<document index="12">
<source>src\global.d.ts</source>
<document_content>
declare namespace Pwamap {
  type ShopData = {
    index: number;
    distance?: number;
    'タイムスタンプ': string;
    '緯度': string;
    '経度': string;
    'スポット名': string;
    'カテゴリ': string;
    '紹介文': string;
    '画像': string;
    '画像2': string;  
    '画像3': string;  
    '画像4': string;  
    '画像5': string;
    '駐車場': string;  
    '創業年月': string;  
    'TEL': string;    
    'URL': string;
    'Instagram': string;
    'Twitter': string;
    'Facebook': string;
    '公式サイト': string
  }

  type LngLat = [number, number]
}

</document_content>
</document>
<document index="13">
<source>src\index.tsx</source>
<document_content>
import React from 'react';
import ReactDOM from 'react-dom';
import { HashRouter } from "react-router-dom";
import Container from './Container';
import './index.scss'
import * as serviceWorkerRegistration from './serviceWorkerRegistration';

ReactDOM.render(
  <React.StrictMode>
    <HashRouter>
      <Container />
    </HashRouter>
  </React.StrictMode>,
  document.getElementById('root')
);

// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: https://bit.ly/CRA-PWA

serviceWorkerRegistration.register();

</document_content>
</document>
<document index="14">
<source>src\Qrcode.tsx</source>
<document_content>
import { useQRCode } from 'next-qrcode';

function Qrcode(props: { url: string }) {

  const { url } = props;
  const { Canvas } = useQRCode();

  return (
    <Canvas
      text={url}
      options={{
        type: 'image/png',
        margin: 0,
        width: 128
      }}
    />
  );
}

export default Qrcode;

</document_content>
</document>
<document index="15">
<source>src\react-app-env.d.ts</source>
<document_content>
/// <reference types="react-scripts" />

</document_content>
</document>
<document index="16">
<source>src\service-worker.ts</source>
<document_content>
/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }: { request: Request; url: URL }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    }

    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith('/_')) {
      return false;
    }

    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'),
  // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Any other custom service worker logic can go here.

</document_content>
</document>
<document index="17">
<source>src\serviceWorkerRegistration.ts</source>
<document_content>
// This optional code is used to register a service worker.
// register() is not called by default.

// This lets the app load faster on subsequent visits in production, and gives
// it offline capabilities. However, it also means that developers (and users)
// will only see deployed updates on subsequent visits to a page, after all the
// existing tabs open on the page have been closed, since previously cached
// resources are updated in the background.

// To learn more about the benefits of this model and instructions on how to
// opt-in, read https://cra.link/PWA

const isLocalhost = Boolean(
  window.location.hostname === 'localhost' ||
    // [::1] is the IPv6 localhost address.
    window.location.hostname === '[::1]' ||
    // 127.0.0.0/8 are considered localhost for IPv4.
    window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)
);

type Config = {
  onSuccess?: (registration: ServiceWorkerRegistration) => void;
  onUpdate?: (registration: ServiceWorkerRegistration) => void;
};

export function register(config?: Config) {
  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {
    // The URL constructor is available in all browsers that support SW.
    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);
    if (publicUrl.origin !== window.location.origin) {
      // Our service worker won't work if PUBLIC_URL is on a different origin
      // from what our page is served on. This might happen if a CDN is used to
      // serve assets; see https://github.com/facebook/create-react-app/issues/2374
      return;
    }

    window.addEventListener('load', () => {
      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;

      if (isLocalhost) {
        // This is running on localhost. Let's check if a service worker still exists or not.
        checkValidServiceWorker(swUrl, config);

        // Add some additional logging to localhost, pointing developers to the
        // service worker/PWA documentation.
        navigator.serviceWorker.ready.then(() => {
          console.log(
            'This web app is being served cache-first by a service ' +
              'worker. To learn more, visit https://cra.link/PWA'
          );
        });
      } else {
        // Is not localhost. Just register service worker
        registerValidSW(swUrl, config);
      }
    });
  }
}

function registerValidSW(swUrl: string, config?: Config) {
  navigator.serviceWorker
    .register(swUrl)
    .then((registration) => {
      registration.onupdatefound = () => {
        const installingWorker = registration.installing;
        if (installingWorker == null) {
          return;
        }
        installingWorker.onstatechange = () => {
          if (installingWorker.state === 'installed') {
            if (navigator.serviceWorker.controller) {
              // At this point, the updated precached content has been fetched,
              // but the previous service worker will still serve the older
              // content until all client tabs are closed.
              console.log(
                'New content is available and will be used when all ' +
                  'tabs for this page are closed. See https://cra.link/PWA.'
              );

              // Execute callback
              if (config && config.onUpdate) {
                config.onUpdate(registration);
              }
            } else {
              // At this point, everything has been precached.
              // It's the perfect time to display a
              // "Content is cached for offline use." message.
              console.log('Content is cached for offline use.');

              // Execute callback
              if (config && config.onSuccess) {
                config.onSuccess(registration);
              }
            }
          }
        };
      };
    })
    .catch((error) => {
      console.error('Error during service worker registration:', error);
    });
}

function checkValidServiceWorker(swUrl: string, config?: Config) {
  // Check if the service worker can be found. If it can't reload the page.
  fetch(swUrl, {
    headers: { 'Service-Worker': 'script' },
  })
    .then((response) => {
      // Ensure service worker exists, and that we really are getting a JS file.
      const contentType = response.headers.get('content-type');
      if (
        response.status === 404 ||
        (contentType != null && contentType.indexOf('javascript') === -1)
      ) {
        // No service worker found. Probably a different app. Reload the page.
        navigator.serviceWorker.ready.then((registration) => {
          registration.unregister().then(() => {
            window.location.reload();
          });
        });
      } else {
        // Service worker found. Proceed as normal.
        registerValidSW(swUrl, config);
      }
    })
    .catch(() => {
      console.log('No internet connection found. App is running in offline mode.');
    });
}

export function unregister() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.ready
      .then((registration) => {
        registration.unregister();
      })
      .catch((error) => {
        console.error(error.message);
      });
  }
}

</document_content>
</document>
<document index="18">
<source>src\setupTests.ts</source>
<document_content>
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom/extend-expect';

</document_content>
</document>
<document index="19">
<source>src\App\Category.tsx</source>
<document_content>
import React from "react";
import Select from 'react-select'
import { useNavigate } from 'react-router-dom';
import './Category.scss'

type Props = {
  data: Pwamap.ShopData[];
}

const Content = (props: Props) => {

  const navigate = useNavigate();

  const [categoryList, setCategoryList] = React.useState<string[]>([]);

  React.useEffect(() => {

    let categories: string[] = []

    for (let i = 0; i < props.data.length; i++) {
      const shop = props.data[i];

      if (categories.indexOf(shop['カテゴリ']) === -1) {

        categories.push(shop['カテゴリ'])
      }

    }

    setCategoryList(categories)

  }, [props.data])


  return (
    <>
      <div className="head"></div>
      <div className="category">
        <div className="container">
          <div className="category-item">
            <label htmlFor="category-select">カテゴリから選ぶ</label>
            <Select
              placeholder="選んでください"
              onChange={(e) => {
                if (e) {
                  navigate(`/list?category=${e.value}`);
                }
              }}
              options={
                categoryList.map(category => {
                  return {
                    value: category,
                    label: category
                  }
                })
              }
            />
          </div>

        </div>
      </div>
    </>
  );
};

export default Content;

</document_content>
</document>
<document index="20">
<source>src\App\Home.tsx</source>
<document_content>
import React from "react";
import Map from "./Map"

type Props = {
  data: Pwamap.ShopData[];
}

const Content = (props: Props) => {
  return (
    <><Map data={props.data} /></>
  );
};

export default Content;

</document_content>
</document>
<document index="21">
<source>src\App\Images.tsx</source>
<document_content>
import { useEffect, useState } from 'react'
import { ImageList, ImageListItem } from '@material-ui/core'
import Shop from './Shop'
import './Images.scss'

type Props = {
  data: Pwamap.ShopData[];
}

const Content = (props: Props) => {

  const { data } = props;
  const [validImageList, setValidImageList ] = useState<JSX.Element[]>([]);
  const [shop, setShop] = useState<Pwamap.ShopData | undefined>()

  const popupHandler = (shop: Pwamap.ShopData) => {
    if (shop) {
      setShop(shop)
    }
  }

  const closeHandler = () => {
    setShop(undefined)
  }

  useEffect(() => {

    let imageListItems = []

    for (let i = 0; i < data.length; i++) {
      const item = data[i];

      if (item['画像']) {

        imageListItems.push(
          <ImageListItem
            key={i}
            className="mui-image-list-item"
          >
            <img
              src={item['画像']}
              alt={item['スポット名']}
              loading="lazy"
              onClick={() => popupHandler(item)}
              onError={e => {
                //@ts-ignore
                e.target.parentNode.remove()
              }}
            />
          </ImageListItem>
        )
      }
    }

    setValidImageList(imageListItems)

  }, [data])

  return (
    <>
      <div className="head"></div>
      <div className="images">
        <div className="container">
          <ImageList id="mui-image-list" sx={{ width: "100%", height: "100%" }} cols={2} rowHeight={164}>
            {validImageList}
          </ImageList>
          {shop ?
            <Shop shop={shop} close={closeHandler} />
            :
            <></>
          }
        </div>
      </div>
    </>
  );
};

export default Content;

</document_content>
</document>
<document index="22">
<source>src\App\Links.tsx</source>
<document_content>
import React from "react";
import { FaTwitter, FaInstagram, FaHome, FaFacebook } from 'react-icons/fa';

import './Links.scss'

type Props = {
  data: Pwamap.ShopData;
};

const noop = (e: React.MouseEvent) => {
  e.stopPropagation()
}

const Content = (props: Props) => {

  return (
    <div className="links">
      {props.data['Instagram']?<div className="link"><a href={`https://instagram.com/${props.data['Instagram']}`}><FaInstagram onClick={noop} size="20px" /></a></div>:''}
      {props.data['Twitter']?<div className="link"><a href={`https://twitter.com/${props.data['Twitter']}`}><FaTwitter onClick={noop} size="20px" /></a></div>:''}
      {props.data['Facebook']?<div className="link"><a href={`https://www.facebook.com/${props.data['Facebook']}`}><FaFacebook onClick={noop} size="20px" /></a></div>:''}
      {props.data['公式サイト']?<div className="link"><a href={props.data['公式サイト']}><FaHome onClick={noop} size="20px" /></a></div>:''}
    </div>
  );
};

export default Content;

</document_content>
</document>
<document index="23">
<source>src\App\List.tsx</source>
<document_content>
import React from "react";
import ShopListItem from './ShopListItem'
import Shop from './Shop'
import './List.scss'
import { useSearchParams } from "react-router-dom";
import InfiniteScroll from 'react-infinite-scroll-component';
import { askGeolocationPermission } from '../geolocation'
import * as turf from "@turf/turf"

type Props = {
  data: Pwamap.ShopData[];
}

const sortShopList = async (shopList: Pwamap.ShopData[]) => {
  const currentPosition = await askGeolocationPermission()
  if(currentPosition) {
    const from = turf.point(currentPosition);
    const sortingShopList = shopList.map((shop) => {
      const lng = parseFloat(shop['経度'])
      const lat = parseFloat(shop['緯度'])
      if(Number.isNaN(lng) || Number.isNaN(lat)) {
        return shop
      } else {
        const to = turf.point([lng, lat])
        const distance = turf.distance(from, to, {units: 'meters' as 'meters'});
        return { ...shop, distance }
      }
    })
    sortingShopList.sort((a,b) => {
      if(typeof a.distance !== 'number' || Number.isNaN(a.distance)) {
        return 1
      } else if (typeof b.distance !== 'number' || Number.isNaN(b.distance)) {
        return -1
      } else {
        return a.distance - b.distance
      }
    })
    return sortingShopList
  } else {
    return shopList
  }
}

const Content = (props: Props) => {

  const [shop, setShop] = React.useState<Pwamap.ShopData | undefined>()
  const [data, setData] = React.useState<Pwamap.ShopData[]>(props.data)
  const [list, setList] = React.useState<any[]>([]);
  const [page, setPage] = React.useState(10);
  const [hasMore, setHasMore] = React.useState(true);

  const [searchParams] = useSearchParams();
  const queryCategory = searchParams.get('category')

  React.useEffect(() => {

    let data = props.data;

    if (queryCategory) {
      data = props.data.filter((shop) => {
        return shop['カテゴリ'] === queryCategory
      })
    }

    let isMounted = true
    // prevent memory leak
    if (isMounted) {

      const orderBy = process.env.REACT_APP_ORDERBY

      if (orderBy === 'distance') {

        sortShopList(data)
          .then(sortedData => {
            // prevent memory leak
            if (isMounted) {
              setList(sortedData.slice(0, page))
              setData(sortedData)
            }
          })

      } else {
        setList(data.slice(0, page))
        setData(data)
      }
    }

    return () => {
      isMounted = false
    }
  }, [props.data, queryCategory, page])


  const popupHandler = (shop: Pwamap.ShopData) => {
    if (shop) {
      setShop(shop)
    }
  }

  const closeHandler = () => {
    setShop(undefined)
  }

    //項目を読み込むときのコールバック
    const loadMore = () => {

      //データ件数が0件の場合、処理終了
      if (list.length >= data.length) {
        setHasMore(false);
        return;
      }

      setList([...list, ...data.slice(page, page + 10)])
      setPage(page + 10)
    }

  const loader = <div
    className="loader"
    key={0}
    style={{
      width: '100%',
      height: '200px',
      textAlign: 'center',
      position: 'relative',
      top: '100px'
    }}
  >場所一覧を読み込み中です...</div>;

  return (
    <div id="shop-list" className="shop-list">
      {queryCategory && <div className="shop-list-category">{`カテゴリ：「${queryCategory}」`}</div>}

      <InfiniteScroll
        dataLength={list.length}
        next={loadMore}
        hasMore={hasMore}
        loader={loader}
        scrollableTarget="shop-list"
      >
        {
          list.map((item, index) => {

            return (<div key={index} className="shop">
              <ShopListItem
                data={item}
                popupHandler={popupHandler}
                queryCategory={queryCategory}
              />
            </div>)

          })
        }
      </InfiniteScroll>
      {shop ?
        <Shop shop={shop} close={closeHandler} />
        :
        <></>
      }
    </div>
  );
};

export default Content;

</document_content>
</document>
<document index="24">
<source>src\App\Map.tsx</source>
<document_content>
import React from "react";
// @ts-ignore
import geojsonExtent from '@mapbox/geojson-extent'
import toGeoJson from './toGeoJson'
import setCluster from './setCluster'
import Shop from './Shop'

type Props = {
  data: Pwamap.ShopData[];
};

const CSS: React.CSSProperties = {
  width: '100%',
  height: '100%',
  position: 'relative',
}

const hidePoiLayers = (map: any) => {

  const hideLayers = [
    'poi',
    'poi-primary',
    'poi-r0-r9',
    'poi-r10-r24',
    'poi-r25',
    'poi-bus',
    'poi-entrance',
  ]

  for (let i = 0; i < hideLayers.length; i++) {
    const layerId = hideLayers[i];
    map.setLayoutProperty(layerId, 'visibility', 'none')
  }
}

const Content = (props: Props) => {
  const mapNode = React.useRef<HTMLDivElement>(null);
  const [mapObject, setMapObject] = React.useState<any>()
  const [shop, setShop] = React.useState<Pwamap.ShopData | undefined>(undefined)

  const addMarkers = (mapObject: any, data: any) => {

    if (!mapObject || data.length === 0) {
      return
    }

    mapObject.on('render', () => {

      // nothing to do if shops exists.
      if (mapObject.getSource('shops')) {
        return
      }

      hidePoiLayers(mapObject)

      const textColor = '#000000'
      const textHaloColor = '#FFFFFF'

      const geojson = toGeoJson(data)

      mapObject.addSource('shops', {
        type: 'geojson',
        data: geojson,
        cluster: true,
        clusterMaxZoom: 14,
        clusterRadius: 25,
      })

      mapObject.addLayer({
        id: 'shop-points',
        type: 'circle',
        source: 'shops',
        filter: ['all',
          ['==', '$type', 'Point'],
        ],
        paint: {
          'circle-radius': 13,
          'circle-color': '#FF0000',
          'circle-opacity': 0.4,
          'circle-stroke-width': 2,
          'circle-stroke-color': '#FFFFFF',
          'circle-stroke-opacity': 1,
        },
      })

      mapObject.addLayer({
        id: 'shop-symbol',
        type: 'symbol',
        source: 'shops',
        filter: ['all',
          ['==', '$type', 'Point'],
        ],
        paint: {
          'text-color': textColor,
          'text-halo-color': textHaloColor,
          'text-halo-width': 2,
        },
        layout: {
          'text-field': "{スポット名}",
          'text-font': ['Noto Sans Regular'],
          'text-variable-anchor': ['top', 'bottom', 'left', 'right'],
          'text-radial-offset': 0.5,
          'text-justify': 'auto',
          'text-size': 12,
          'text-anchor': 'top',
          'text-max-width': 12,
          'text-allow-overlap': false,
        },
      })

      mapObject.on('mouseenter', 'shop-points', () => {
        mapObject.getCanvas().style.cursor = 'pointer'
      })

      mapObject.on('mouseleave', 'shop-points', () => {
        mapObject.getCanvas().style.cursor = ''
      })

      mapObject.on('mouseenter', 'shop-symbol', () => {
        mapObject.getCanvas().style.cursor = 'pointer'
      })

      mapObject.on('mouseleave', 'shop-symbol', () => {
        mapObject.getCanvas().style.cursor = ''
      })

      mapObject.on('click', 'shop-points', (event: any) => {
        if (!event.features[0].properties.cluster) {
          setShop(event.features[0].properties)
        }
      })

      mapObject.on('click', 'shop-symbol', (event: any) => {
        if (!event.features[0].properties.cluster) {
          setShop(event.features[0].properties)
        }
      })

      setCluster(mapObject)


    });

  }

  React.useEffect(() => {

    addMarkers(mapObject, props.data)

  }, [mapObject, props.data])

  React.useEffect(() => {
    if (!mapObject || props.data.length === 0) {
      return
    }
    const geojson = toGeoJson(props.data)
    const bounds = geojsonExtent(geojson)

    if (bounds) {
      mapObject.fitBounds(bounds, {
        padding: 50
      })
    }
  }, [mapObject, props.data])

  React.useEffect(() => {
    // Only once reder the map.
    if (!mapNode.current || mapObject) {
      return
    }

    // @ts-ignore
    const { geolonia } = window;

    const map = new geolonia.Map({
      container: mapNode.current,
      style: 'geolonia/gsi',
    });

    const onMapLoad = () => {
      hidePoiLayers(map)
      setMapObject(map)
    }

    const orienteationchangeHandler = () => {
      map.resize()
    }

    // attach
    map.on('load', onMapLoad)

    window.addEventListener('orientationchange', orienteationchangeHandler)

    return () => {
      // detach to prevent memory leak
      window.removeEventListener('orientationchange', orienteationchangeHandler)
      map.off('load', onMapLoad)
    }
  }, [mapNode, mapObject, props.data])

  const closeHandler = () => {
    setShop(undefined)
  }

  return (
    <div style={CSS}>
      <div
        ref={mapNode}
        style={CSS}
        data-geolocate-control="on"
        data-marker="off"
        data-gesture-handling="off"
      ></div>
      {shop ?
        <Shop shop={shop} close={closeHandler} />
        :
        <></>
      }
    </div>
  );
};

export default Content;

</document_content>
</document>
<document index="25">
<source>src\App\setCluster.ts</source>
<document_content>
const setCluster = (map: any) => {
  map.addLayer({
    id: 'clusters',
    type: 'circle',
    source: 'shops',
    filter: ['has', 'point_count'],
    paint: {
      'circle-radius': 20,
      'circle-color': '#FF0000',
      'circle-opacity': 1.0,
    },
  })

  map.addLayer({
    id: 'cluster-count',
    type: 'symbol',
    source: 'shops',
    filter: ['has', 'point_count'],
    paint: {
      'text-color': '#FFFFFF',
    },
    layout: {
      'text-field': '{point_count_abbreviated} 件',
      'text-size': 12,
      'text-font': ['Noto Sans Regular'],
    },
  })

  map.on('click', 'clusters', (e: any) => {
    const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] })
    const clusterId = features[0].properties.cluster_id
    map.getSource('shops').getClusterExpansionZoom(clusterId, (err: any, zoom: number) => {
      if (err)
        return

      map.easeTo({
        center: features[0].geometry.coordinates,
        zoom: zoom,
      })
    })
  })

  map.on('mouseenter', 'clusters', function () {
    map.getCanvas().style.cursor = 'pointer'
  })

  map.on('mouseleave', 'clusters', function () {
    map.getCanvas().style.cursor = ''
  })
}

export default setCluster;

</document_content>
</document>
<document index="26">
<source>src\App\Share.tsx</source>
<document_content>
import React from "react";
import { FacebookShareButton, LineShareButton, TwitterShareButton } from "react-share";
import { FacebookIcon, LineIcon, TwitterIcon } from "react-share";
import config from '../config.json'

import './Share.scss'

const Content = () => {
  const url = window.location.href.replace(/\?.+$/, '').replace(/#.+$/, '')

  return (
    <div className="share">
      <ul>
        <li><a href="/"><TwitterShareButton url={url} hashtags={[`${config.title}`]} title={`${config.title}`}><TwitterIcon size={32} round={true} /></TwitterShareButton></a></li>
        <li><a href="/"><FacebookShareButton url={url} hashtag={`#${config.title}`}><FacebookIcon size={32} round={true} /></FacebookShareButton></a></li>
        <li><a href="/"><LineShareButton url={url} title={`${config.title}`}><LineIcon size={32} round={true} /></LineShareButton></a></li>
      </ul>
    </div>
  );
};

export default Content;

</document_content>
</document>
<document index="27">
<source>src\App\Shop.tsx</source>
<document_content>
import React from "react";
import Links from './Links'
import './Shop.scss'
import { AiOutlineClose } from 'react-icons/ai'
import { Link } from "react-router-dom";
import { makeDistanceLabelText } from "./distance-label";

type Props = {
  shop: Pwamap.ShopData;
  close: Function;
}

const Content = (props: Props) => {
  const mapNode = React.useRef<HTMLDivElement>(null);
  const [map, setMap] = React.useState<any>(null)
  const { shop } = props

  const clickHandler = () => {
    props.close()
    if(mapNode.current) {
      mapNode.current.remove()
      map.remove()
    }
  }

  React.useEffect(() => {
    if (!mapNode.current) {
      return
    }

    // @ts-ignore
    const nextMap = new window.geolonia.Map({
      container: mapNode.current,
      interactive: false,
      zoom: 14,
      style: `geolonia/gsi`,
    });
    setMap(nextMap)
  }, [shop, mapNode])

  const distanceTipText = makeDistanceLabelText(shop.distance)
  const category = shop['カテゴリ']
  const content = shop['紹介文']

  const toBreakLine = (text: string) => {

    return text.split(/(\r\n)|(\n)|(\r)/g).map((line, i) => {

      let result: any = '';

      if (line === '\r\n' || line === '\n' || line === '\r') {
        result = <br key={i} />
      } else if (line !== undefined) {
        result = line
      }

      return result
    })
  }

  return (
    <div className="shop-single">
      <div className="head">
        <button onClick={clickHandler}><AiOutlineClose size="16px" color="#FFFFFF" /> 閉じる</button>
      </div>
      <div className="container">
        {shop?
          <>
            <h2>{shop['スポット名']}</h2>
            <div>
              <span className="nowrap">
                <Link to={`/list?category=${category}`}>
                  <span onClick={clickHandler} className="category">{category}</span>
                </Link>
              </span>
              <span className="nowrap">{distanceTipText && <span className="distance">現在位置から {distanceTipText}</span> }</span>
              <span className="nowrap">{distanceTipText && <span className="history">創業年月  {shop['創業年月']}</span> }</span>

            </div>
            
            <h3> 駐車場 : {shop['駐車場']}</h3>            
            <div style={{margin: "24px 0"}}><Links data={shop} /></div>
          
            <div>
            { shop['画像'] && <img src={shop['画像']} alt={shop['スポット名']} style={{width: "100%"}} />}

            { shop['画像2'] && <img src={shop['画像2']} alt={shop['スポット名']} style={{width: "100%"}} />}

            { shop['画像3'] && <img src={shop['画像3']} alt={shop['スポット名']} style={{width: "100%"}} />}

            { shop['画像4'] && <img src={shop['画像4']} alt={shop['スポット名']} style={{width: "100%"}} />}

            { shop['画像5'] && <img src={shop['画像5']} alt={shop['スポット名']} style={{width: "100%"}} />}

            </div>
            
            <p style={{margin: "24px 0", wordBreak: "break-all"}}>{toBreakLine(content)}</p>

                        <p style={{margin: "24px 0", wordBreak: "break-all"}}>{toBreakLine(content)}</p>

                        <p style={{margin: "24px 0", wordBreak: "break-all"}}>{toBreakLine(content)}</p>

                        <p style={{margin: "24px 0", wordBreak: "break-all"}}>{toBreakLine(content)}</p>

            <div
              ref={mapNode}
              style={{width: '100%', height: '200px', marginTop: "24px"}}
              data-lat={shop['緯度']}
              data-lng={shop['経度']}
              data-navigation-control="off"
            ></div>

            <h3><a className="small" href={`http://maps.apple.com/?q=${shop['緯度']},${shop['経度']}`}>この店までの道順を調べる</a></h3>

          </>
          :
          <></>
        }
      </div>
    </div>
  );
};

export default Content;

</document_content>
</document>
<document index="28">
<source>src\App\ShopListItem.tsx</source>
<document_content>
import { BsChevronCompactRight } from 'react-icons/bs'
import './ShopListItem.scss'
import { Link } from "react-router-dom";
import { makeDistanceLabelText } from "./distance-label";

type Props = {
  data: Pwamap.ShopData;
  popupHandler: Function;
  queryCategory: string | null;
};

const Content = (props: Props) => {
  const clickHandler = () => {
    props.popupHandler(props.data)
  }

  const distanceTipText = makeDistanceLabelText(props.data.distance)
  const category = props.data['カテゴリ']
  const image = props.data['画像']

  const isCategoryPage = props.queryCategory ? true :false

  return (
    <>
      <div className="shop-link">
        <h2 className="shop-title" style={{ wordBreak: "break-all" }} onClick={clickHandler}>{props.data['スポット名']}</h2>
        <div className='tag-box'>
          {
            !isCategoryPage &&
            <span className="nowrap">
              <Link to={`/list?category=${category}`}>
                <span className="category">{category}</span>
              </Link>
            </span>
          }
          <span className="nowrap">{distanceTipText && <span className="distance">現在位置から {distanceTipText}</span>}</span>
        </div>

        <div style={{ margin: "10px 10px 10px 0" }}>

          { image && <img src={image} alt={props.data['スポット名']} onClick={clickHandler}/>}

        </div>

        <div className="right" onClick={clickHandler}><BsChevronCompactRight size="40px" color="#CCCCCC" /></div>
      </div>
    </>
  );
};

export default Content;

</document_content>
</document>
<document index="29">
<source>src\App\Tabbar.tsx</source>
<document_content>
import React from "react";
import { Link } from "react-router-dom";
import './Tabbar.scss'

import { FaList, FaHome, FaSearch, FaCamera } from "react-icons/fa"
import { AiOutlineAppstore } from "react-icons/ai"

const Content = () => {
  return (
    <div className="tabbar">
      <ul>
        <li><Link to="/"><div className="icon"><FaHome /></div><div className="text">ホーム</div></Link></li>
        <li><Link to="/list"><div className="icon"><FaList /></div><div className="text">一覧</div></Link></li>
        <li><Link to="/category"><div className="icon"><FaSearch /></div><div className="text">カテゴリ</div></Link></li>
        <li><Link to="/images"><div className="icon"><FaCamera /></div><div className="text">写真から探す</div></Link></li>
        <li><Link to="/about"><div className="icon"><AiOutlineAppstore /></div><div className="text">マップについて</div></Link></li>
      </ul>
    </div>
  );
};

export default Content;

</document_content>
</document>
<document index="30">
<source>src\App\toGeoJson.ts</source>
<document_content>
type Geometry = {
  type: string;
  coordinates: number[]
}

type featureProperties = {
  [key: string]: string;
}

type Feature = {
  type: string;
  geometry: Geometry;
  properties: featureProperties
}

type itemObject = {
  [key: string]: any;
}

type GeoJSON = {
  type: string;
  features: Feature[]
}

const toGeoJson = (data: any) => {
  const geojson = {
    type: "FeatureCollection",
    features: []
  } as GeoJSON

  for (const id in data) {
    const item = data[id] as itemObject

    if (!item['経度'] || !item['緯度'] || !item['スポット名']) {
      return;
    }

    const feature = {
      type: "Feature",
      geometry: {
        type: "Point",
        coordinates: [Number(item['経度']), Number(item['緯度'])]
      },
      properties: {_id: id}
    } as Feature

    for (let i = 0; i < Object.keys(item).length; i++) {
      const key = Object.keys(item)[i]
      feature.properties[key] = item[key]
    }

    geojson.features.push(feature)
  }

  return geojson
}

export default toGeoJson;

</document_content>
</document>
<document index="31">
<source>src\lib\table2json.ts</source>
<document_content>
import zen2han from "./zen2han";

const table2json = (table: Array<Array<string>>) => {
  const header = table[0]
  const records = table.slice(1)

  return records.map((record: Array<string>) => {

    const properties = header.reduce((prev: any, column: any) => {
      const value = record[header.indexOf(column)];
      prev[column] = zen2han(value || '');
      return prev;
    }, {});
    return properties;
  });

}

export default table2json;

</document_content>
</document>
<document index="32">
<source>src\lib\zen2han.ts</source>
<document_content>
const zen2han = (str: string) => {
  return str.replace(/[！-～]/g, function (s: string) {
    return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
  }).replace(/　/g, ' ');
}

export default zen2han;

</document_content>
</document>
</documents>
